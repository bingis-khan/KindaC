

class Functor
	MapResult a
	Item

	map (self _, fn Item -> b) -> MapResult b

# if it's a List, Vector, whatever - return new iterator. if it's an iterator already, return itself.
class IntoIter
	ThisIter: Iter  # this adds typeclass constraints!
	it (self _) -> ThisIter


class Iter
	Item
	next (self Ptr _) -> Maybe Item


inst Functor IntoIter
	Item = IntoIter.ThisIter.Iter.Item
	MapResult a = MapWith _ a
	map (self _, fn Item -> b) -> MapWith _ b
		i = self it()
		return MapWith(i, fn)



# str

# tbh, implementation does not matter that much yet kek. we can change it later.
# i can just make it out of printfs rn now. later, we might copy into some buffer, or use a provided function.
class Str
	print (self _) -> Unit
	
# special version of tuple used to (statically) concat strings.
ConcatStr l r: ConcatStr l r
inst Str (ConcatStr l r): Str l, Str r
	print-str (ConcatStr(l, r) _) -> Unit
		print-str l
		print-str r

#[ctype "const char*"]
ConstStr

# just a printf("%s") wrapper
#[cfun "print_const_str"]
# also, 'extern' keyword was used. maybe I'll change it later, it's trivial. I shouldn't also "fear" changing it.
extern print-const-str (s ConstStr) -> Unit

inst Str ConstStr
	print-str (s ConstStr)





# ------------------------------
             it()  next() map()
List          V            V
ListIter      V      V     V
MapIter       V      V     V


from this, the structure is as follows:

class IntoIter
	ThisIter: Iter

	it () -> ThisIter

	# or just: it () -> Iter

inst Functor IntoIter
	map (...) # (implementation, uses Iter's map implementation)


class Iter
	Item
	next (self Ptr _) -> Maybe Item

inst Functor Iter
	map (...)  # (implementation)

# burh, how do we differentiate which instance to use...
# either it's Functor IntoIter or Functor Iter for lists....
# or!!!! (this is kinda backwards, but works.)

# (don't define Functor Iter)

inst Functor IntoIter
	Result a = MapIter a
	Item = IntoIter.ThisIter.Iter.Item  # ?????
	map (x _, fn Item -> b) -> Result b
		i = x it()
		return MapIter(i, fn)


# also, a problem with different map()s...

do-sth (it) -> Maybe a
	it map() first()

# if `it` -> List, then it'll compile.
# if it's `it` -> Maybe a, then it will also compile, but the types will be different!!
# this should fail typechecking
# so, you have to annotate!

do-sth (it IntoIter) -> Maybe a
	it map() first()

do-str (it Maybe a) -> Maybe a
	it map() first()


# this is kinda meh - now, we have to annotate shit. maybe there is a better way???
# the problem is, that the type is hidden away - there is no way to introduce constraints on it.
# so, maybe functional dependencies????

class Iter item a | a -> item
	next (self a) -> Maybe item

# this is basically a multi parameter + functional dependencies extension.
