use Cnile
use StrClass
	Str(print-str, length, chars)
use Iter
	IntoIter(into-iter)
	Iter(next)
	all
	zip
	head
use Slice
	Slice
	subslice
use Retarded

# in the future, this should re-export Str class

concat (l a, r b) -> StrConcat a b <= Str a, Str b
	return StrConcat(l, r)


# temporary function for string equality
const-eq (l ConstStr, r ConstStr): Cnile.strcmp(l, r) == 0

tupeq (Tuple(l, r)): l == r
# for some reason, uncurry((l, r): l == r) generates an empty union somewhere during monomorphisation.
eq (l, r): length(l) == length(r) and l chars() zip(r chars()) all(tupeq)

char (s): s chars() head()

is-whitespace (c):
	   c == char(' ')
	or c == char('\n')
	or c == char('\t')

is-blank (s): s chars() all(is-whitespace)


# dyn str
DynStr
	content Slice Cnile.Char

# i want to do substrings differently later.
substr (s DynStr, from Int, to Int):
	DynStr { content: s.content subslice(from, to) }

code2char (code Int) -> Cnile.Char
	return Retarded.cast(code)

char2code (char Cnile.Char) -> Int
	return Retarded.cast(char)


LineIter
	og DynStr
	last Int

lines (s DynStr): LineIter { og: s, last: 0 }

inst IntoIter LineIter
	into-iter (self LineIter): self



newline = code2char(10)
nullchar = code2char(0)

inst Iter LineIter
	next (self Ptr LineIter) -> Maybe DynStr
		# should consume the last trailing newline
		if self&.last >= self&.og.content.count or self&.og.content Slice.get(self&.last) == nullchar
			return None

		# iterator is left after last encountered newline
		i = self&.last
		while self&.og.content Slice.get(i) /= newline and i < self&.og.content.count
			i <= i + 1

		line = self&.og substr(self&.last, i)
		i <= i + 1  # skip past the newline

		# modify the state
		self <&.last= i

		return Just(line)



DynStrIter
	og Slice.SliceIter Cnile.Char

inst IntoIter DynStrIter
	into-iter (self): self

inst Iter DynStrIter
	next (self)
		n = next(&self&.og)
		if n == Just(nullchar)
			return None
		return n

inst Str DynStr
	print-str (self DynStr) -> Unit
		Cnile.printf2('%.*s', self.content.count, self.content.ptr)
		return

	length (self DynStr) -> Int
		return self.content.count - 1

	chars (self):
		DynStrIter { og: self.content into-iter() }

