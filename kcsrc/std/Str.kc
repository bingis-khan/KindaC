use Cnile

class Str
	# later should write to some buffer instead of printing directly.
	print-str (self _) -> Unit
	length (self _) -> Int


concat (l a, r b) -> StrConcat a b <= Str a, Str b
	return StrConcat(l, r)


# ConstStr is defined in Prelude
inst Str ConstStr
	print-str (self ConstStr) -> Unit
		Cnile.printf('%s', self)
		return

	length (self ConstStr) -> Int
		return Cnile.strlen(self)

inst Str Unit
	print-str (self Unit) -> Unit
		print-str('Unit')
		return

	length (self Unit) -> Int
		return 4

inst Str Int
	print-str (self Int) -> Unit
		Cnile.printf('%d', self)
		return

	length (self Int) -> Int
		if self == 0
			return 1
			
		digits = 0
		while self > 0
			self <= self / 10
			digits <= digits + 1

		return digits

inst Str Bool
	print-str (self Bool) -> Unit
		if self
			print-str('True')
		else
			print-str('False')
		return

	length (self Bool) -> Int
		if self
			return 4  # 'True': 4
		else
			return 5  # 'False': 5

inst Str StrConcat l r
	print-str (StrConcat(l, r)) -> Unit
		print-str(l)
		print-str(r)
		return

	length (StrConcat(l, r)) -> Int
		return length(l) + length(r)


inst Str Maybe a
	print-str (self Maybe a) -> Unit <= Str a
		case self
			Just(x)
				print-str(concat('Just(', concat(x, ')')))
			None
				print-str('None')

	length (self Maybe a) -> Int <= Str a
		case self
			None
				return 4

			Just(x)
				return 5 + length(x) + 1

inst Str Ptr a
	print-str (Ptr(self) Ptr a) -> Unit <= Str a
		print-str('Ptr(\(self))')

	length (Ptr(self) Ptr a) -> Int <= Str a
		return 4 + length(self) + 1


inst Str Tuple l r
	print-str (Tuple(l, r)) -> Unit
		print-str('(\(l), \(r))')
		return

	length (Tuple(l, r)) -> Int
		return 1 + length(l) + 2 + length(r) + 1
