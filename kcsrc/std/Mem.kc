use Cnile
use Str
	Str(print-str, length)
use Iter
	IntoIter(into-iter)
	Iter(next)


# Module for memory operations!
# REMEMBER THE IDEALS: IT'S A USER FACING MODULE,
# SO IN THE "FINAL" VERSION, WE SHOULD OPERATE ON SLICES,
# AND NOT ON RAW POINTERS, ETC!!!!
# ALLOC SHOULD RETURN A SLICE!

# also, stuff to think about:
# what is the "official" way to check the size of something?
# is a 'Proxy' a good way to do that?
# should we have a "Type structure", which contains it?
#  ex. x type() type-size()

# or just something like:
# size-of(x)

# but how do we get the size of a nested type?
# i guess we should have a function, eg. pointed-size(x) or something.

# but also, currently we don't do it like C does, we have to pass all the memory of a struct to get the size, which is kinda bad... but it works........ ahhh fuk i should write this somewhere visible so I won't forget.


offset-ptr(x Ptr a, count Int) -> Ptr a
	return Cnile.shitty-offset-ptr(x, count)


undefined () -> a
	# this is such a hack I wanna kms
	# maybe i should just add an 'undefined' keyword-thingy-operator?
	#[goofy-ahh-undefined-return]
	return

TypeSize a
	size Int

get-typesize () -> TypeSize a  # don't need no arguments here!
	return TypeSize { size: Cnile.sizeof(undefined() as a) }  # this is crap, because we are creating a large undefined value and passing it to `sizeof`. We should somehow pass a type instead.

size-of (x a) -> Int
	typesize = get-typesize() as TypeSize a
	return typesize.size

ptr-size-of (x Ptr a) -> Int
	typesize = get-typesize() as TypeSize a
	return typesize.size

cast-ptr(p Ptr a) -> Ptr b
	return Cnile.cast(p)


zeroed () -> a
	x = undefined()
	Cnile.memset(Cnile.cast(&x), 0, Cnile.sizeof(x))
	return x

